# Test vectors

This directory contains binary files with pre-serialized test
vectors.  Each file contains a single structure in a TLS-syntax
format defined below (in each case, the `XXXTestVectors` struct).

## Tree Math

File: [tree_math.bin](https://github.com/mlswg/mls-implementations/blob/master/test_vectors/tree_math.bin)

```
struct {
  uint32 root<0..2^32-1>;
  uint32 left<0..2^32-1>;
  uint32 right<0..2^32-1>;
  uint32 parent<0..2^32-1>;
  uint32 sibling<0..2^32-1>;
} TreeMathTestVectors;
```

These vectors have the following meaning, where the tree relations
are as defined in [the specification](https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#tree-computation-terminology):

* `root[i]` is the index of the root of a tree with `i+1` leaves
* The remaining vectors are all within the context of a tree with
  255 leaves:
  * `left[i]` is the index of the left child of node `i` 
  * `right[i]` is the index of the right child of node `i` 
  * `parent[i]` is the index of the parent of node `i` 
  * `sibling[i]` is the index of the sibling of node `i` 

Your implementation's tree math library should be able to reproduce
these values.


## Cryptographic Functions

```
struct {
  opaque hkdf_extract_out<0..255>;
  opaque derive_secret_out<0..255>;
  DHPublicKey derive_key_pair_pub;
  ECIESCiphertext ecies_out;
} CryptoCase;

struct {
  opaque hkdf_extract_salt<0..255>;
  opaque hkdf_extract_ikm<0..255>;
  opaque derive_secret_salt<0..255>;
  opaque derive_secret_label<0..255>;
  uint32 derive_secret_length;
  opaque derive_key_pair_seed<0..255>;
  opaque ecies_plaintext<0..255>;

  CryptoCase case_p256_p256;
  CryptoCase case_x25519_ed25519;
  CryptoCase case_p521_p521;
  CryptoCase case_x448_ed448;
} CryptoTestVectors;
```

The `CryptoTestVectors` struct contains the inputs to cryptographic
functions, and the `CryptoCase` members hold the outputs when using
the indicated ciphersuites.  The following functions are tested:

* `HKDF-Extract`
* `Derive-Secret`
  * The `salt` and `label` arguments are provided
  * The `State` argument should be initialized with the following
    contents:
    * `group_id` and `transcript_hash`: The zero-length octet string
    * `epoch`: 0
    * `roster`, `tree`: Zero-length vectors
  * That is, the state should serialize to a sequence of 14 zeros
* `Derive-Key-Pair`
* ECIES
  * Encryption and decryption is done using the key pair generated
    in the `Derive-Key-Pair` stage.
  * The encryption phase is made deterministic by deriving the
    ephemeral key pair from the inputs.
  * `(skE, pkE)  = Derive-Key-Pair(pkR || plaintext)`, where `pkR`
    is the serialization of the recipient's public key (the body of
    a `DHPublicKey`, with no length octets), and `plaintext` is the
    plaintext being encrypted.

Your implementation should be able to reproduce these values.


## Message Parsing and Serialization

File: [messages.bin](https://github.com/mlswg/mls-implementations/blob/master/test_vectors/messages.bin)

```
struct {
  CipherSuite cipher_suite;
  SignatureScheme sig_scheme;

  opaque user_init_key<0..2^32-1>;
  opaque welcome_info<0..2^32-1>;
  opaque welcome<0..2^32-1>;
  opaque add<0..2^32-1>;
  opaque update<0..2^32-1>;
  opaque remove<0..2^32-1>;
} CipherSuiteCase;

struct {
  uint32_t epoch;
  uint32_t signer_index;
  uint32_t removed;
  opaque user_id<0..255>;
  opaque group_id<0..255>;
  opaque uik_id<0..255>;
  opaque dh_seed<0..255>;
  opaque sig_seed<0..255>;
  opaque random<0..255>;

  SignatureScheme uik_all_scheme;
  UserInitKey user_init_key_all;

  CipherSuiteCase case_p256_p256;
  CipherSuiteCase case_x25519_ed25519;
  CipherSuiteCase case_p521_p521;
  CipherSuiteCase case_x448_ed448;
} MessagesTestVectors;
```

The elements of the struct have the following meanings:

* The first several fields contain the values used to construct the
  example messages.
* `user_init_key_all` contains a UserInitKey that offers all four
  ciphersuites.  It is validly signed with an Ed448 key.
* The remaining cases each test message processing for a given
  ciphersuite:
  * `case_p256_p256` uses P256 for DH and ECDSA-P256 for signing
  * `case_x25519_ed25519` uses X25519 for DH and Ed25519 for signing
  * `case_p521_p521` uses P521 for DH and ECDSA-P521 for signing
  * `case_x448_ed448` uses X448 for DH and Ed448 for signing
* In each case:
  * `user_init_key` contains a UserInitKey offering only the
    indicated ciphersuite, validly signed with the corresponding
    signature scheme
  * `welcome_info` contains a `WelcomeInfo` message with
    syntactically valid but bogus contents
  * `welcome` contains a Welcome message generated by encrypting
    `welcome_info` for a Diffie-Hellman public key derived from the
    `dh_seed` value.
  * `add`, `update`, and `remove` each contain a Handshake message
    with a GroupOperation of the corresponding type.  The signatures
    on these messages are not valid

Your implementation should be able to pass the following tests:

* `user_init_key_all` should parse successfully 
* The test cases for any supported ciphersuites should parse
  successfully
* All of the above parsed values should survive a marshal /
  unmarshal round-trip
